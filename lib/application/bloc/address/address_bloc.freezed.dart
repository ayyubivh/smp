// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'address_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AddressEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchCities,
    required TResult Function() fetchAddress,
    required TResult Function(double? currentLat, double? currentLong,
            String? state, String? city, String? pincode)
        updateLocation,
    required TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)
        addAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchCities,
    TResult? Function()? fetchAddress,
    TResult? Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult? Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchCities,
    TResult Function()? fetchAddress,
    TResult Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchCities value) fetchCities,
    required TResult Function(_FetchAddress value) fetchAddress,
    required TResult Function(_UpdateLocation value) updateLocation,
    required TResult Function(_AddAddress value) addAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchCities value)? fetchCities,
    TResult? Function(_FetchAddress value)? fetchAddress,
    TResult? Function(_UpdateLocation value)? updateLocation,
    TResult? Function(_AddAddress value)? addAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchCities value)? fetchCities,
    TResult Function(_FetchAddress value)? fetchAddress,
    TResult Function(_UpdateLocation value)? updateLocation,
    TResult Function(_AddAddress value)? addAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressEventCopyWith<$Res> {
  factory $AddressEventCopyWith(
          AddressEvent value, $Res Function(AddressEvent) then) =
      _$AddressEventCopyWithImpl<$Res, AddressEvent>;
}

/// @nodoc
class _$AddressEventCopyWithImpl<$Res, $Val extends AddressEvent>
    implements $AddressEventCopyWith<$Res> {
  _$AddressEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FetchCitiesImplCopyWith<$Res> {
  factory _$$FetchCitiesImplCopyWith(
          _$FetchCitiesImpl value, $Res Function(_$FetchCitiesImpl) then) =
      __$$FetchCitiesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchCitiesImplCopyWithImpl<$Res>
    extends _$AddressEventCopyWithImpl<$Res, _$FetchCitiesImpl>
    implements _$$FetchCitiesImplCopyWith<$Res> {
  __$$FetchCitiesImplCopyWithImpl(
      _$FetchCitiesImpl _value, $Res Function(_$FetchCitiesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchCitiesImpl implements _FetchCities {
  const _$FetchCitiesImpl();

  @override
  String toString() {
    return 'AddressEvent.fetchCities()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchCitiesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchCities,
    required TResult Function() fetchAddress,
    required TResult Function(double? currentLat, double? currentLong,
            String? state, String? city, String? pincode)
        updateLocation,
    required TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)
        addAddress,
  }) {
    return fetchCities();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchCities,
    TResult? Function()? fetchAddress,
    TResult? Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult? Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
  }) {
    return fetchCities?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchCities,
    TResult Function()? fetchAddress,
    TResult Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
    required TResult orElse(),
  }) {
    if (fetchCities != null) {
      return fetchCities();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchCities value) fetchCities,
    required TResult Function(_FetchAddress value) fetchAddress,
    required TResult Function(_UpdateLocation value) updateLocation,
    required TResult Function(_AddAddress value) addAddress,
  }) {
    return fetchCities(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchCities value)? fetchCities,
    TResult? Function(_FetchAddress value)? fetchAddress,
    TResult? Function(_UpdateLocation value)? updateLocation,
    TResult? Function(_AddAddress value)? addAddress,
  }) {
    return fetchCities?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchCities value)? fetchCities,
    TResult Function(_FetchAddress value)? fetchAddress,
    TResult Function(_UpdateLocation value)? updateLocation,
    TResult Function(_AddAddress value)? addAddress,
    required TResult orElse(),
  }) {
    if (fetchCities != null) {
      return fetchCities(this);
    }
    return orElse();
  }
}

abstract class _FetchCities implements AddressEvent {
  const factory _FetchCities() = _$FetchCitiesImpl;
}

/// @nodoc
abstract class _$$FetchAddressImplCopyWith<$Res> {
  factory _$$FetchAddressImplCopyWith(
          _$FetchAddressImpl value, $Res Function(_$FetchAddressImpl) then) =
      __$$FetchAddressImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchAddressImplCopyWithImpl<$Res>
    extends _$AddressEventCopyWithImpl<$Res, _$FetchAddressImpl>
    implements _$$FetchAddressImplCopyWith<$Res> {
  __$$FetchAddressImplCopyWithImpl(
      _$FetchAddressImpl _value, $Res Function(_$FetchAddressImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchAddressImpl implements _FetchAddress {
  const _$FetchAddressImpl();

  @override
  String toString() {
    return 'AddressEvent.fetchAddress()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchAddressImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchCities,
    required TResult Function() fetchAddress,
    required TResult Function(double? currentLat, double? currentLong,
            String? state, String? city, String? pincode)
        updateLocation,
    required TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)
        addAddress,
  }) {
    return fetchAddress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchCities,
    TResult? Function()? fetchAddress,
    TResult? Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult? Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
  }) {
    return fetchAddress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchCities,
    TResult Function()? fetchAddress,
    TResult Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
    required TResult orElse(),
  }) {
    if (fetchAddress != null) {
      return fetchAddress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchCities value) fetchCities,
    required TResult Function(_FetchAddress value) fetchAddress,
    required TResult Function(_UpdateLocation value) updateLocation,
    required TResult Function(_AddAddress value) addAddress,
  }) {
    return fetchAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchCities value)? fetchCities,
    TResult? Function(_FetchAddress value)? fetchAddress,
    TResult? Function(_UpdateLocation value)? updateLocation,
    TResult? Function(_AddAddress value)? addAddress,
  }) {
    return fetchAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchCities value)? fetchCities,
    TResult Function(_FetchAddress value)? fetchAddress,
    TResult Function(_UpdateLocation value)? updateLocation,
    TResult Function(_AddAddress value)? addAddress,
    required TResult orElse(),
  }) {
    if (fetchAddress != null) {
      return fetchAddress(this);
    }
    return orElse();
  }
}

abstract class _FetchAddress implements AddressEvent {
  const factory _FetchAddress() = _$FetchAddressImpl;
}

/// @nodoc
abstract class _$$UpdateLocationImplCopyWith<$Res> {
  factory _$$UpdateLocationImplCopyWith(_$UpdateLocationImpl value,
          $Res Function(_$UpdateLocationImpl) then) =
      __$$UpdateLocationImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {double? currentLat,
      double? currentLong,
      String? state,
      String? city,
      String? pincode});
}

/// @nodoc
class __$$UpdateLocationImplCopyWithImpl<$Res>
    extends _$AddressEventCopyWithImpl<$Res, _$UpdateLocationImpl>
    implements _$$UpdateLocationImplCopyWith<$Res> {
  __$$UpdateLocationImplCopyWithImpl(
      _$UpdateLocationImpl _value, $Res Function(_$UpdateLocationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentLat = freezed,
    Object? currentLong = freezed,
    Object? state = freezed,
    Object? city = freezed,
    Object? pincode = freezed,
  }) {
    return _then(_$UpdateLocationImpl(
      currentLat: freezed == currentLat
          ? _value.currentLat
          : currentLat // ignore: cast_nullable_to_non_nullable
              as double?,
      currentLong: freezed == currentLong
          ? _value.currentLong
          : currentLong // ignore: cast_nullable_to_non_nullable
              as double?,
      state: freezed == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _value.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      pincode: freezed == pincode
          ? _value.pincode
          : pincode // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$UpdateLocationImpl implements _UpdateLocation {
  const _$UpdateLocationImpl(
      {this.currentLat, this.currentLong, this.state, this.city, this.pincode});

  @override
  final double? currentLat;
  @override
  final double? currentLong;
  @override
  final String? state;
  @override
  final String? city;
  @override
  final String? pincode;

  @override
  String toString() {
    return 'AddressEvent.updateLocation(currentLat: $currentLat, currentLong: $currentLong, state: $state, city: $city, pincode: $pincode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateLocationImpl &&
            (identical(other.currentLat, currentLat) ||
                other.currentLat == currentLat) &&
            (identical(other.currentLong, currentLong) ||
                other.currentLong == currentLong) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.pincode, pincode) || other.pincode == pincode));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, currentLat, currentLong, state, city, pincode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateLocationImplCopyWith<_$UpdateLocationImpl> get copyWith =>
      __$$UpdateLocationImplCopyWithImpl<_$UpdateLocationImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchCities,
    required TResult Function() fetchAddress,
    required TResult Function(double? currentLat, double? currentLong,
            String? state, String? city, String? pincode)
        updateLocation,
    required TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)
        addAddress,
  }) {
    return updateLocation(currentLat, currentLong, state, city, pincode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchCities,
    TResult? Function()? fetchAddress,
    TResult? Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult? Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
  }) {
    return updateLocation?.call(currentLat, currentLong, state, city, pincode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchCities,
    TResult Function()? fetchAddress,
    TResult Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
    required TResult orElse(),
  }) {
    if (updateLocation != null) {
      return updateLocation(currentLat, currentLong, state, city, pincode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchCities value) fetchCities,
    required TResult Function(_FetchAddress value) fetchAddress,
    required TResult Function(_UpdateLocation value) updateLocation,
    required TResult Function(_AddAddress value) addAddress,
  }) {
    return updateLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchCities value)? fetchCities,
    TResult? Function(_FetchAddress value)? fetchAddress,
    TResult? Function(_UpdateLocation value)? updateLocation,
    TResult? Function(_AddAddress value)? addAddress,
  }) {
    return updateLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchCities value)? fetchCities,
    TResult Function(_FetchAddress value)? fetchAddress,
    TResult Function(_UpdateLocation value)? updateLocation,
    TResult Function(_AddAddress value)? addAddress,
    required TResult orElse(),
  }) {
    if (updateLocation != null) {
      return updateLocation(this);
    }
    return orElse();
  }
}

abstract class _UpdateLocation implements AddressEvent {
  const factory _UpdateLocation(
      {final double? currentLat,
      final double? currentLong,
      final String? state,
      final String? city,
      final String? pincode}) = _$UpdateLocationImpl;

  double? get currentLat;
  double? get currentLong;
  String? get state;
  String? get city;
  String? get pincode;
  @JsonKey(ignore: true)
  _$$UpdateLocationImplCopyWith<_$UpdateLocationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddAddressImplCopyWith<$Res> {
  factory _$$AddAddressImplCopyWith(
          _$AddAddressImpl value, $Res Function(_$AddAddressImpl) then) =
      __$$AddAddressImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String? home,
      String? apartment,
      String? bloc,
      String? floor,
      String? flatNo2,
      bool? avoidCalling,
      bool? ringBell,
      bool? guard,
      bool? drop,
      bool? doorstep,
      bool isAddOrEdit,
      String? id});
}

/// @nodoc
class __$$AddAddressImplCopyWithImpl<$Res>
    extends _$AddressEventCopyWithImpl<$Res, _$AddAddressImpl>
    implements _$$AddAddressImplCopyWith<$Res> {
  __$$AddAddressImplCopyWithImpl(
      _$AddAddressImpl _value, $Res Function(_$AddAddressImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? home = freezed,
    Object? apartment = freezed,
    Object? bloc = freezed,
    Object? floor = freezed,
    Object? flatNo2 = freezed,
    Object? avoidCalling = freezed,
    Object? ringBell = freezed,
    Object? guard = freezed,
    Object? drop = freezed,
    Object? doorstep = freezed,
    Object? isAddOrEdit = null,
    Object? id = freezed,
  }) {
    return _then(_$AddAddressImpl(
      home: freezed == home
          ? _value.home
          : home // ignore: cast_nullable_to_non_nullable
              as String?,
      apartment: freezed == apartment
          ? _value.apartment
          : apartment // ignore: cast_nullable_to_non_nullable
              as String?,
      bloc: freezed == bloc
          ? _value.bloc
          : bloc // ignore: cast_nullable_to_non_nullable
              as String?,
      floor: freezed == floor
          ? _value.floor
          : floor // ignore: cast_nullable_to_non_nullable
              as String?,
      flatNo2: freezed == flatNo2
          ? _value.flatNo2
          : flatNo2 // ignore: cast_nullable_to_non_nullable
              as String?,
      avoidCalling: freezed == avoidCalling
          ? _value.avoidCalling
          : avoidCalling // ignore: cast_nullable_to_non_nullable
              as bool?,
      ringBell: freezed == ringBell
          ? _value.ringBell
          : ringBell // ignore: cast_nullable_to_non_nullable
              as bool?,
      guard: freezed == guard
          ? _value.guard
          : guard // ignore: cast_nullable_to_non_nullable
              as bool?,
      drop: freezed == drop
          ? _value.drop
          : drop // ignore: cast_nullable_to_non_nullable
              as bool?,
      doorstep: freezed == doorstep
          ? _value.doorstep
          : doorstep // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAddOrEdit: null == isAddOrEdit
          ? _value.isAddOrEdit
          : isAddOrEdit // ignore: cast_nullable_to_non_nullable
              as bool,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$AddAddressImpl implements _AddAddress {
  const _$AddAddressImpl(
      {this.home,
      this.apartment,
      this.bloc,
      this.floor,
      this.flatNo2,
      this.avoidCalling,
      this.ringBell,
      this.guard,
      this.drop,
      this.doorstep,
      required this.isAddOrEdit,
      this.id});

  @override
  final String? home;
  @override
  final String? apartment;
  @override
  final String? bloc;
  @override
  final String? floor;
  @override
  final String? flatNo2;
  @override
  final bool? avoidCalling;
  @override
  final bool? ringBell;
  @override
  final bool? guard;
  @override
  final bool? drop;
  @override
  final bool? doorstep;
  @override
  final bool isAddOrEdit;
  @override
  final String? id;

  @override
  String toString() {
    return 'AddressEvent.addAddress(home: $home, apartment: $apartment, bloc: $bloc, floor: $floor, flatNo2: $flatNo2, avoidCalling: $avoidCalling, ringBell: $ringBell, guard: $guard, drop: $drop, doorstep: $doorstep, isAddOrEdit: $isAddOrEdit, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddAddressImpl &&
            (identical(other.home, home) || other.home == home) &&
            (identical(other.apartment, apartment) ||
                other.apartment == apartment) &&
            (identical(other.bloc, bloc) || other.bloc == bloc) &&
            (identical(other.floor, floor) || other.floor == floor) &&
            (identical(other.flatNo2, flatNo2) || other.flatNo2 == flatNo2) &&
            (identical(other.avoidCalling, avoidCalling) ||
                other.avoidCalling == avoidCalling) &&
            (identical(other.ringBell, ringBell) ||
                other.ringBell == ringBell) &&
            (identical(other.guard, guard) || other.guard == guard) &&
            (identical(other.drop, drop) || other.drop == drop) &&
            (identical(other.doorstep, doorstep) ||
                other.doorstep == doorstep) &&
            (identical(other.isAddOrEdit, isAddOrEdit) ||
                other.isAddOrEdit == isAddOrEdit) &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, home, apartment, bloc, floor,
      flatNo2, avoidCalling, ringBell, guard, drop, doorstep, isAddOrEdit, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddAddressImplCopyWith<_$AddAddressImpl> get copyWith =>
      __$$AddAddressImplCopyWithImpl<_$AddAddressImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchCities,
    required TResult Function() fetchAddress,
    required TResult Function(double? currentLat, double? currentLong,
            String? state, String? city, String? pincode)
        updateLocation,
    required TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)
        addAddress,
  }) {
    return addAddress(home, apartment, bloc, floor, flatNo2, avoidCalling,
        ringBell, guard, drop, doorstep, isAddOrEdit, id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchCities,
    TResult? Function()? fetchAddress,
    TResult? Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult? Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
  }) {
    return addAddress?.call(home, apartment, bloc, floor, flatNo2, avoidCalling,
        ringBell, guard, drop, doorstep, isAddOrEdit, id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchCities,
    TResult Function()? fetchAddress,
    TResult Function(double? currentLat, double? currentLong, String? state,
            String? city, String? pincode)?
        updateLocation,
    TResult Function(
            String? home,
            String? apartment,
            String? bloc,
            String? floor,
            String? flatNo2,
            bool? avoidCalling,
            bool? ringBell,
            bool? guard,
            bool? drop,
            bool? doorstep,
            bool isAddOrEdit,
            String? id)?
        addAddress,
    required TResult orElse(),
  }) {
    if (addAddress != null) {
      return addAddress(home, apartment, bloc, floor, flatNo2, avoidCalling,
          ringBell, guard, drop, doorstep, isAddOrEdit, id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchCities value) fetchCities,
    required TResult Function(_FetchAddress value) fetchAddress,
    required TResult Function(_UpdateLocation value) updateLocation,
    required TResult Function(_AddAddress value) addAddress,
  }) {
    return addAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchCities value)? fetchCities,
    TResult? Function(_FetchAddress value)? fetchAddress,
    TResult? Function(_UpdateLocation value)? updateLocation,
    TResult? Function(_AddAddress value)? addAddress,
  }) {
    return addAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchCities value)? fetchCities,
    TResult Function(_FetchAddress value)? fetchAddress,
    TResult Function(_UpdateLocation value)? updateLocation,
    TResult Function(_AddAddress value)? addAddress,
    required TResult orElse(),
  }) {
    if (addAddress != null) {
      return addAddress(this);
    }
    return orElse();
  }
}

abstract class _AddAddress implements AddressEvent {
  const factory _AddAddress(
      {final String? home,
      final String? apartment,
      final String? bloc,
      final String? floor,
      final String? flatNo2,
      final bool? avoidCalling,
      final bool? ringBell,
      final bool? guard,
      final bool? drop,
      final bool? doorstep,
      required final bool isAddOrEdit,
      final String? id}) = _$AddAddressImpl;

  String? get home;
  String? get apartment;
  String? get bloc;
  String? get floor;
  String? get flatNo2;
  bool? get avoidCalling;
  bool? get ringBell;
  bool? get guard;
  bool? get drop;
  bool? get doorstep;
  bool get isAddOrEdit;
  String? get id;
  @JsonKey(ignore: true)
  _$$AddAddressImplCopyWith<_$AddAddressImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddressState {
  List<CityModel>? get cities => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  AddressModel? get addressModel => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddressStateCopyWith<AddressState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressStateCopyWith<$Res> {
  factory $AddressStateCopyWith(
          AddressState value, $Res Function(AddressState) then) =
      _$AddressStateCopyWithImpl<$Res, AddressState>;
  @useResult
  $Res call(
      {List<CityModel>? cities, bool isLoading, AddressModel? addressModel});

  $AddressModelCopyWith<$Res>? get addressModel;
}

/// @nodoc
class _$AddressStateCopyWithImpl<$Res, $Val extends AddressState>
    implements $AddressStateCopyWith<$Res> {
  _$AddressStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cities = freezed,
    Object? isLoading = null,
    Object? addressModel = freezed,
  }) {
    return _then(_value.copyWith(
      cities: freezed == cities
          ? _value.cities
          : cities // ignore: cast_nullable_to_non_nullable
              as List<CityModel>?,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      addressModel: freezed == addressModel
          ? _value.addressModel
          : addressModel // ignore: cast_nullable_to_non_nullable
              as AddressModel?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressModelCopyWith<$Res>? get addressModel {
    if (_value.addressModel == null) {
      return null;
    }

    return $AddressModelCopyWith<$Res>(_value.addressModel!, (value) {
      return _then(_value.copyWith(addressModel: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AddressStateImplCopyWith<$Res>
    implements $AddressStateCopyWith<$Res> {
  factory _$$AddressStateImplCopyWith(
          _$AddressStateImpl value, $Res Function(_$AddressStateImpl) then) =
      __$$AddressStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<CityModel>? cities, bool isLoading, AddressModel? addressModel});

  @override
  $AddressModelCopyWith<$Res>? get addressModel;
}

/// @nodoc
class __$$AddressStateImplCopyWithImpl<$Res>
    extends _$AddressStateCopyWithImpl<$Res, _$AddressStateImpl>
    implements _$$AddressStateImplCopyWith<$Res> {
  __$$AddressStateImplCopyWithImpl(
      _$AddressStateImpl _value, $Res Function(_$AddressStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cities = freezed,
    Object? isLoading = null,
    Object? addressModel = freezed,
  }) {
    return _then(_$AddressStateImpl(
      cities: freezed == cities
          ? _value._cities
          : cities // ignore: cast_nullable_to_non_nullable
              as List<CityModel>?,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      addressModel: freezed == addressModel
          ? _value.addressModel
          : addressModel // ignore: cast_nullable_to_non_nullable
              as AddressModel?,
    ));
  }
}

/// @nodoc

class _$AddressStateImpl implements _AddressState {
  const _$AddressStateImpl(
      {required final List<CityModel>? cities,
      required this.isLoading,
      required this.addressModel})
      : _cities = cities;

  final List<CityModel>? _cities;
  @override
  List<CityModel>? get cities {
    final value = _cities;
    if (value == null) return null;
    if (_cities is EqualUnmodifiableListView) return _cities;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool isLoading;
  @override
  final AddressModel? addressModel;

  @override
  String toString() {
    return 'AddressState(cities: $cities, isLoading: $isLoading, addressModel: $addressModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressStateImpl &&
            const DeepCollectionEquality().equals(other._cities, _cities) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.addressModel, addressModel) ||
                other.addressModel == addressModel));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_cities), isLoading, addressModel);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressStateImplCopyWith<_$AddressStateImpl> get copyWith =>
      __$$AddressStateImplCopyWithImpl<_$AddressStateImpl>(this, _$identity);
}

abstract class _AddressState implements AddressState {
  const factory _AddressState(
      {required final List<CityModel>? cities,
      required final bool isLoading,
      required final AddressModel? addressModel}) = _$AddressStateImpl;

  @override
  List<CityModel>? get cities;
  @override
  bool get isLoading;
  @override
  AddressModel? get addressModel;
  @override
  @JsonKey(ignore: true)
  _$$AddressStateImplCopyWith<_$AddressStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
